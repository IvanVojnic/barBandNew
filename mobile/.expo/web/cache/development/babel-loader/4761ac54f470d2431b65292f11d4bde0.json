{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _jsxFileName = \"D:\\\\\\u043F\\u0440\\u043E\\u0435\\u043A\\u0442\\u044B \\u043B\\u0435\\u0442\\u043E\\u043C 2022\\\\loginapp2\\\\mobile\\\\node_modules\\\\react-native\\\\Libraries\\\\Components\\\\ScrollView\\\\ScrollViewStickyHeader.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar AnimatedImplementation = require(\"../../Animated/src/AnimatedImplementation\");\n\nvar React = require('react');\n\nvar StyleSheet = require(\"../../StyleSheet/StyleSheet\");\n\nvar View = require(\"../View/View\");\n\nvar AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\nvar ScrollViewStickyHeader = function (_React$Component) {\n  _inherits(ScrollViewStickyHeader, _React$Component);\n\n  var _super = _createSuper(ScrollViewStickyHeader);\n\n  function ScrollViewStickyHeader() {\n    var _this;\n\n    _classCallCheck(this, ScrollViewStickyHeader);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.state = {\n      measured: false,\n      layoutY: 0,\n      layoutHeight: 0,\n      nextHeaderLayoutY: _this.props.nextHeaderLayoutY\n    };\n\n    _this._onLayout = function (event) {\n      _this.setState({\n        measured: true,\n        layoutY: event.nativeEvent.layout.y,\n        layoutHeight: event.nativeEvent.layout.height\n      });\n\n      _this.props.onLayout(event);\n\n      var child = React.Children.only(_this.props.children);\n\n      if (child.props.onLayout) {\n        child.props.onLayout(event);\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(ScrollViewStickyHeader, [{\n    key: \"setNextHeaderY\",\n    value: function setNextHeaderY(y) {\n      this.setState({\n        nextHeaderLayoutY: y\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          inverted = _this$props.inverted,\n          scrollViewHeight = _this$props.scrollViewHeight;\n      var _this$state = this.state,\n          measured = _this$state.measured,\n          layoutHeight = _this$state.layoutHeight,\n          layoutY = _this$state.layoutY,\n          nextHeaderLayoutY = _this$state.nextHeaderLayoutY;\n      var inputRange = [-1, 0];\n      var outputRange = [0, 0];\n\n      if (measured) {\n        if (inverted) {\n          if (scrollViewHeight != null) {\n            var stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n\n            if (stickStartPoint > 0) {\n              inputRange.push(stickStartPoint);\n              outputRange.push(0);\n              inputRange.push(stickStartPoint + 1);\n              outputRange.push(1);\n              var collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n\n              if (collisionPoint > stickStartPoint) {\n                inputRange.push(collisionPoint, collisionPoint + 1);\n                outputRange.push(collisionPoint - stickStartPoint, collisionPoint - stickStartPoint);\n              }\n            }\n          }\n        } else {\n          inputRange.push(layoutY);\n          outputRange.push(0);\n\n          var _collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n\n          if (_collisionPoint >= layoutY) {\n            inputRange.push(_collisionPoint, _collisionPoint + 1);\n            outputRange.push(_collisionPoint - layoutY, _collisionPoint - layoutY);\n          } else {\n            inputRange.push(layoutY + 1);\n            outputRange.push(1);\n          }\n        }\n      }\n\n      var translateY = this.props.scrollAnimatedValue.interpolate({\n        inputRange: inputRange,\n        outputRange: outputRange\n      });\n      var child = React.Children.only(this.props.children);\n      return React.createElement(AnimatedView, {\n        collapsable: false,\n        onLayout: this._onLayout,\n        style: [child.props.style, styles.header, {\n          transform: [{\n            translateY: translateY\n          }]\n        }],\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 144,\n          columnNumber: 7\n        }\n      }, React.cloneElement(child, {\n        style: styles.fill,\n        onLayout: undefined\n      }));\n    }\n  }]);\n\n  return ScrollViewStickyHeader;\n}(React.Component);\n\nvar styles = StyleSheet.create({\n  header: {\n    zIndex: 10\n  },\n  fill: {\n    flex: 1\n  }\n});\nmodule.exports = ScrollViewStickyHeader;","map":{"version":3,"names":["AnimatedImplementation","require","React","StyleSheet","View","AnimatedView","createAnimatedComponent","ScrollViewStickyHeader","state","measured","layoutY","layoutHeight","nextHeaderLayoutY","props","_onLayout","event","setState","nativeEvent","layout","y","height","onLayout","child","Children","only","children","inverted","scrollViewHeight","inputRange","outputRange","stickStartPoint","push","collisionPoint","translateY","scrollAnimatedValue","interpolate","style","styles","header","transform","cloneElement","fill","undefined","Component","create","zIndex","flex","module","exports"],"sources":["D:/проекты летом 2022/loginapp2/mobile/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nconst AnimatedImplementation = require('../../Animated/src/AnimatedImplementation');\nconst React = require('react');\nconst StyleSheet = require('../../StyleSheet/StyleSheet');\nconst View = require('../View/View');\n\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\n\nconst AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\nexport type Props = {\n  children?: React.Element<any>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: AnimatedImplementation.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n  ...\n};\n\ntype State = {\n  measured: boolean,\n  layoutY: number,\n  layoutHeight: number,\n  nextHeaderLayoutY: ?number,\n  ...\n};\n\nclass ScrollViewStickyHeader extends React.Component<Props, State> {\n  state: State = {\n    measured: false,\n    layoutY: 0,\n    layoutHeight: 0,\n    nextHeaderLayoutY: this.props.nextHeaderLayoutY,\n  };\n\n  setNextHeaderY(y: number) {\n    this.setState({nextHeaderLayoutY: y});\n  }\n\n  _onLayout = event => {\n    this.setState({\n      measured: true,\n      layoutY: event.nativeEvent.layout.y,\n      layoutHeight: event.nativeEvent.layout.height,\n    });\n\n    this.props.onLayout(event);\n    const child = React.Children.only(this.props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  render(): React.Node {\n    const {inverted, scrollViewHeight} = this.props;\n    const {measured, layoutHeight, layoutY, nextHeaderLayoutY} = this.state;\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    const translateY = this.props.scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n    const child = React.Children.only(this.props.children);\n\n    return (\n      <AnimatedView\n        collapsable={false}\n        onLayout={this._onLayout}\n        style={[child.props.style, styles.header, {transform: [{translateY}]}]}>\n        {React.cloneElement(child, {\n          style: styles.fill, // We transfer the child style to the wrapper.\n          onLayout: undefined, // we call this manually through our this._onLayout\n        })}\n      </AnimatedView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nmodule.exports = ScrollViewStickyHeader;\n"],"mappings":"AAUA;;;;;;;;;;;;;;;;;;AAEA,IAAMA,sBAAsB,GAAGC,OAAO,6CAAtC;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,IAAME,UAAU,GAAGF,OAAO,+BAA1B;;AACA,IAAMG,IAAI,GAAGH,OAAO,gBAApB;;AAIA,IAAMI,YAAY,GAAGL,sBAAsB,CAACM,uBAAvB,CAA+CF,IAA/C,CAArB;;IAuBMG,sB;;;;;;;;;;;;;;;UACJC,K,GAAe;MACbC,QAAQ,EAAE,KADG;MAEbC,OAAO,EAAE,CAFI;MAGbC,YAAY,EAAE,CAHD;MAIbC,iBAAiB,EAAE,MAAKC,KAAL,CAAWD;IAJjB,C;;UAWfE,S,GAAY,UAAAC,KAAK,EAAI;MACnB,MAAKC,QAAL,CAAc;QACZP,QAAQ,EAAE,IADE;QAEZC,OAAO,EAAEK,KAAK,CAACE,WAAN,CAAkBC,MAAlB,CAAyBC,CAFtB;QAGZR,YAAY,EAAEI,KAAK,CAACE,WAAN,CAAkBC,MAAlB,CAAyBE;MAH3B,CAAd;;MAMA,MAAKP,KAAL,CAAWQ,QAAX,CAAoBN,KAApB;;MACA,IAAMO,KAAK,GAAGpB,KAAK,CAACqB,QAAN,CAAeC,IAAf,CAAoB,MAAKX,KAAL,CAAWY,QAA/B,CAAd;;MACA,IAAIH,KAAK,CAACT,KAAN,CAAYQ,QAAhB,EAA0B;QACxBC,KAAK,CAACT,KAAN,CAAYQ,QAAZ,CAAqBN,KAArB;MACD;IACF,C;;;;;;;WAhBD,wBAAeI,CAAf,EAA0B;MACxB,KAAKH,QAAL,CAAc;QAACJ,iBAAiB,EAAEO;MAApB,CAAd;IACD;;;WAgBD,kBAAqB;MACnB,kBAAqC,KAAKN,KAA1C;MAAA,IAAOa,QAAP,eAAOA,QAAP;MAAA,IAAiBC,gBAAjB,eAAiBA,gBAAjB;MACA,kBAA6D,KAAKnB,KAAlE;MAAA,IAAOC,QAAP,eAAOA,QAAP;MAAA,IAAiBE,YAAjB,eAAiBA,YAAjB;MAAA,IAA+BD,OAA/B,eAA+BA,OAA/B;MAAA,IAAwCE,iBAAxC,eAAwCA,iBAAxC;MACA,IAAMgB,UAAyB,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,CAAlC;MACA,IAAMC,WAA0B,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAnC;;MAEA,IAAIpB,QAAJ,EAAc;QACZ,IAAIiB,QAAJ,EAAc;UAeZ,IAAIC,gBAAgB,IAAI,IAAxB,EAA8B;YAC5B,IAAMG,eAAe,GAAGpB,OAAO,GAAGC,YAAV,GAAyBgB,gBAAjD;;YACA,IAAIG,eAAe,GAAG,CAAtB,EAAyB;cACvBF,UAAU,CAACG,IAAX,CAAgBD,eAAhB;cACAD,WAAW,CAACE,IAAZ,CAAiB,CAAjB;cACAH,UAAU,CAACG,IAAX,CAAgBD,eAAe,GAAG,CAAlC;cACAD,WAAW,CAACE,IAAZ,CAAiB,CAAjB;cAGA,IAAMC,cAAc,GAClB,CAACpB,iBAAiB,IAAI,CAAtB,IAA2BD,YAA3B,GAA0CgB,gBAD5C;;cAEA,IAAIK,cAAc,GAAGF,eAArB,EAAsC;gBACpCF,UAAU,CAACG,IAAX,CAAgBC,cAAhB,EAAgCA,cAAc,GAAG,CAAjD;gBACAH,WAAW,CAACE,IAAZ,CACEC,cAAc,GAAGF,eADnB,EAEEE,cAAc,GAAGF,eAFnB;cAID;YACF;UACF;QACF,CAnCD,MAmCO;UAWLF,UAAU,CAACG,IAAX,CAAgBrB,OAAhB;UACAmB,WAAW,CAACE,IAAZ,CAAiB,CAAjB;;UAGA,IAAMC,eAAc,GAAG,CAACpB,iBAAiB,IAAI,CAAtB,IAA2BD,YAAlD;;UACA,IAAIqB,eAAc,IAAItB,OAAtB,EAA+B;YAC7BkB,UAAU,CAACG,IAAX,CAAgBC,eAAhB,EAAgCA,eAAc,GAAG,CAAjD;YACAH,WAAW,CAACE,IAAZ,CAAiBC,eAAc,GAAGtB,OAAlC,EAA2CsB,eAAc,GAAGtB,OAA5D;UACD,CAHD,MAGO;YACLkB,UAAU,CAACG,IAAX,CAAgBrB,OAAO,GAAG,CAA1B;YACAmB,WAAW,CAACE,IAAZ,CAAiB,CAAjB;UACD;QACF;MACF;;MAED,IAAME,UAAU,GAAG,KAAKpB,KAAL,CAAWqB,mBAAX,CAA+BC,WAA/B,CAA2C;QAC5DP,UAAU,EAAVA,UAD4D;QAE5DC,WAAW,EAAXA;MAF4D,CAA3C,CAAnB;MAIA,IAAMP,KAAK,GAAGpB,KAAK,CAACqB,QAAN,CAAeC,IAAf,CAAoB,KAAKX,KAAL,CAAWY,QAA/B,CAAd;MAEA,OACE,oBAAC,YAAD;QACE,WAAW,EAAE,KADf;QAEE,QAAQ,EAAE,KAAKX,SAFjB;QAGE,KAAK,EAAE,CAACQ,KAAK,CAACT,KAAN,CAAYuB,KAAb,EAAoBC,MAAM,CAACC,MAA3B,EAAmC;UAACC,SAAS,EAAE,CAAC;YAACN,UAAU,EAAVA;UAAD,CAAD;QAAZ,CAAnC,CAHT;QAAA;QAAA;UAAA;UAAA;UAAA;QAAA;MAAA,GAIG/B,KAAK,CAACsC,YAAN,CAAmBlB,KAAnB,EAA0B;QACzBc,KAAK,EAAEC,MAAM,CAACI,IADW;QAEzBpB,QAAQ,EAAEqB;MAFe,CAA1B,CAJH,CADF;IAWD;;;;EA/GkCxC,KAAK,CAACyC,S;;AAkH3C,IAAMN,MAAM,GAAGlC,UAAU,CAACyC,MAAX,CAAkB;EAC/BN,MAAM,EAAE;IACNO,MAAM,EAAE;EADF,CADuB;EAI/BJ,IAAI,EAAE;IACJK,IAAI,EAAE;EADF;AAJyB,CAAlB,CAAf;AASAC,MAAM,CAACC,OAAP,GAAiBzC,sBAAjB"},"metadata":{},"sourceType":"script"}