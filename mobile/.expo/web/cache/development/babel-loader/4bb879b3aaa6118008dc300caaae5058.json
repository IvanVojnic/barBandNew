{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport Constants from 'expo-constants';\nimport { CodedError, Platform, SyntheticPlatformEmitter } from 'expo-modules-core';\nexport default function getDevicePushTokenAsync() {\n  var data;\n  return _regeneratorRuntime.async(function getDevicePushTokenAsync$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        _context.next = 2;\n        return _regeneratorRuntime.awrap(_subscribeDeviceToPushNotificationsAsync());\n      case 2:\n        data = _context.sent;\n        SyntheticPlatformEmitter.emit('onDevicePushToken', {\n          devicePushToken: data\n        });\n        return _context.abrupt(\"return\", {\n          type: Platform.OS,\n          data: data\n        });\n      case 5:\n      case \"end\":\n        return _context.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction guardPermission() {\n  if (!('Notification' in window)) {\n    throw new CodedError('ERR_UNAVAILABLE', 'The Web Notifications API is not available on this device.');\n  }\n  if (!navigator.serviceWorker) {\n    throw new CodedError('ERR_UNAVAILABLE', 'Notifications cannot be used because the service worker API is not supported on this device. This might also happen because your web page does not support HTTPS.');\n  }\n  if (Notification.permission !== 'granted') {\n    throw new CodedError('ERR_NOTIFICATIONS_PERMISSION_DENIED', \"Cannot use web notifications without permissions granted. Request permissions with \\\"expo-permissions\\\".\");\n  }\n}\nfunction _subscribeDeviceToPushNotificationsAsync() {\n  var _Constants$expoConfig, _Constants$expoConfig2, _Constants$expoConfig3, _Constants$expoConfig4, _Constants$expoConfig5, _Constants$expoConfig6;\n  var vapidPublicKey, serviceWorkerPath, registration, subscribeOptions, pushSubscription, pushSubscriptionJson, subscriptionObject, notificationIcon;\n  return _regeneratorRuntime.async(function _subscribeDeviceToPushNotificationsAsync$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        vapidPublicKey = (_Constants$expoConfig = Constants.expoConfig) == null ? void 0 : (_Constants$expoConfig2 = _Constants$expoConfig.notification) == null ? void 0 : _Constants$expoConfig2.vapidPublicKey;\n        if (vapidPublicKey) {\n          _context2.next = 3;\n          break;\n        }\n        throw new CodedError('ERR_NOTIFICATIONS_PUSH_WEB_MISSING_CONFIG', 'You must provide `notification.vapidPublicKey` in `app.json` to use push notifications on web. Learn more: https://docs.expo.dev/versions/latest/guides/using-vapid/.');\n      case 3:\n        serviceWorkerPath = (_Constants$expoConfig3 = Constants.expoConfig) == null ? void 0 : (_Constants$expoConfig4 = _Constants$expoConfig3.notification) == null ? void 0 : _Constants$expoConfig4.serviceWorkerPath;\n        if (serviceWorkerPath) {\n          _context2.next = 6;\n          break;\n        }\n        throw new CodedError('ERR_NOTIFICATIONS_PUSH_MISSING_CONFIGURATION', 'You must specify `notification.serviceWorkerPath` in `app.json` to use push notifications on the web. Please provide the path to the service worker that will handle notifications.');\n      case 6:\n        guardPermission();\n        registration = null;\n        _context2.prev = 8;\n        _context2.next = 11;\n        return _regeneratorRuntime.awrap(navigator.serviceWorker.register(serviceWorkerPath));\n      case 11:\n        registration = _context2.sent;\n        _context2.next = 17;\n        break;\n      case 14:\n        _context2.prev = 14;\n        _context2.t0 = _context2[\"catch\"](8);\n        throw new CodedError('ERR_NOTIFICATIONS_PUSH_REGISTRATION_FAILED', \"Could not register this device for push notifications because the service worker (\" + serviceWorkerPath + \") could not be registered: \" + _context2.t0);\n      case 17:\n        _context2.next = 19;\n        return _regeneratorRuntime.awrap(navigator.serviceWorker.ready);\n      case 19:\n        if (registration.active) {\n          _context2.next = 21;\n          break;\n        }\n        throw new CodedError('ERR_NOTIFICATIONS_PUSH_REGISTRATION_FAILED', 'Could not register this device for push notifications because the service worker is not active.');\n      case 21:\n        subscribeOptions = {\n          userVisibleOnly: true,\n          applicationServerKey: _urlBase64ToUint8Array(vapidPublicKey)\n        };\n        pushSubscription = null;\n        _context2.prev = 23;\n        _context2.next = 26;\n        return _regeneratorRuntime.awrap(registration.pushManager.subscribe(subscribeOptions));\n      case 26:\n        pushSubscription = _context2.sent;\n        _context2.next = 32;\n        break;\n      case 29:\n        _context2.prev = 29;\n        _context2.t1 = _context2[\"catch\"](23);\n        throw new CodedError('ERR_NOTIFICATIONS_PUSH_REGISTRATION_FAILED', 'The device was unable to register for remote notifications with the browser endpoint. (' + _context2.t1 + ')');\n      case 32:\n        pushSubscriptionJson = pushSubscription.toJSON();\n        subscriptionObject = {\n          endpoint: pushSubscriptionJson.endpoint,\n          keys: {\n            p256dh: pushSubscriptionJson.keys.p256dh,\n            auth: pushSubscriptionJson.keys.auth\n          }\n        };\n        notificationIcon = ((_Constants$expoConfig5 = (_Constants$expoConfig6 = Constants.expoConfig) == null ? void 0 : _Constants$expoConfig6.notification) != null ? _Constants$expoConfig5 : {}).icon;\n        _context2.next = 37;\n        return _regeneratorRuntime.awrap(registration.active.postMessage(JSON.stringify({\n          fromExpoWebClient: {\n            notificationIcon: notificationIcon\n          }\n        })));\n      case 37:\n        return _context2.abrupt(\"return\", subscriptionObject);\n      case 38:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, null, null, [[8, 14], [23, 29]], Promise);\n}\nfunction _urlBase64ToUint8Array(base64String) {\n  var padding = '='.repeat((4 - base64String.length % 4) % 4);\n  var base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');\n  var rawData = window.atob(base64);\n  var outputArray = new Uint8Array(rawData.length);\n  for (var i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}","map":{"version":3,"mappings":"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","names":["Constants","CodedError","Platform","SyntheticPlatformEmitter","getDevicePushTokenAsync","_subscribeDeviceToPushNotificationsAsync","data","emit","devicePushToken","type","OS","guardPermission","window","navigator","serviceWorker","Notification","permission","vapidPublicKey","expoConfig","notification","serviceWorkerPath","registration","register","ready","active","subscribeOptions","userVisibleOnly","applicationServerKey","_urlBase64ToUint8Array","pushSubscription","pushManager","subscribe","pushSubscriptionJson","toJSON","subscriptionObject","endpoint","keys","p256dh","auth","notificationIcon","icon","postMessage","JSON","stringify","fromExpoWebClient","base64String","padding","repeat","length","base64","replace","rawData","atob","outputArray","Uint8Array","i","charCodeAt"],"sourceRoot":"","sources":["../src/getDevicePushTokenAsync.web.ts"],"sourcesContent":["import Constants from 'expo-constants';\nimport { CodedError, Platform, SyntheticPlatformEmitter } from 'expo-modules-core';\n\nimport { DevicePushToken } from './Tokens.types';\n\nexport default async function getDevicePushTokenAsync(): Promise<DevicePushToken> {\n  const data = await _subscribeDeviceToPushNotificationsAsync();\n  SyntheticPlatformEmitter.emit('onDevicePushToken', { devicePushToken: data });\n  return { type: Platform.OS, data };\n}\n\nfunction guardPermission() {\n  if (!('Notification' in window)) {\n    throw new CodedError(\n      'ERR_UNAVAILABLE',\n      'The Web Notifications API is not available on this device.'\n    );\n  }\n  if (!navigator.serviceWorker) {\n    throw new CodedError(\n      'ERR_UNAVAILABLE',\n      'Notifications cannot be used because the service worker API is not supported on this device. This might also happen because your web page does not support HTTPS.'\n    );\n  }\n  if (Notification.permission !== 'granted') {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_PERMISSION_DENIED',\n      `Cannot use web notifications without permissions granted. Request permissions with \"expo-permissions\".`\n    );\n  }\n}\n\nasync function _subscribeDeviceToPushNotificationsAsync(): Promise<DevicePushToken['data']> {\n  // @ts-expect-error: TODO: not on the schema\n  const vapidPublicKey: string | null = Constants.expoConfig?.notification?.vapidPublicKey;\n  if (!vapidPublicKey) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_PUSH_WEB_MISSING_CONFIG',\n      'You must provide `notification.vapidPublicKey` in `app.json` to use push notifications on web. Learn more: https://docs.expo.dev/versions/latest/guides/using-vapid/.'\n    );\n  }\n\n  // @ts-expect-error: TODO: not on the schema\n  const serviceWorkerPath = Constants.expoConfig?.notification?.serviceWorkerPath;\n  if (!serviceWorkerPath) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_PUSH_MISSING_CONFIGURATION',\n      'You must specify `notification.serviceWorkerPath` in `app.json` to use push notifications on the web. Please provide the path to the service worker that will handle notifications.'\n    );\n  }\n  guardPermission();\n\n  let registration: ServiceWorkerRegistration | null = null;\n  try {\n    registration = await navigator.serviceWorker.register(serviceWorkerPath);\n  } catch (error) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_PUSH_REGISTRATION_FAILED',\n      `Could not register this device for push notifications because the service worker (${serviceWorkerPath}) could not be registered: ${error}`\n    );\n  }\n  await navigator.serviceWorker.ready;\n\n  if (!registration.active) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_PUSH_REGISTRATION_FAILED',\n      'Could not register this device for push notifications because the service worker is not active.'\n    );\n  }\n\n  const subscribeOptions = {\n    userVisibleOnly: true,\n    applicationServerKey: _urlBase64ToUint8Array(vapidPublicKey),\n  };\n  let pushSubscription: PushSubscription | null = null;\n  try {\n    pushSubscription = await registration.pushManager.subscribe(subscribeOptions);\n  } catch (error) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_PUSH_REGISTRATION_FAILED',\n      'The device was unable to register for remote notifications with the browser endpoint. (' +\n        error +\n        ')'\n    );\n  }\n  const pushSubscriptionJson = pushSubscription.toJSON();\n\n  const subscriptionObject = {\n    endpoint: pushSubscriptionJson.endpoint,\n    keys: {\n      p256dh: pushSubscriptionJson.keys!.p256dh,\n      auth: pushSubscriptionJson.keys!.auth,\n    },\n  };\n\n  // Store notification icon string in service worker.\n  // This message is received by `/expo-service-worker.js`.\n  // We wrap it with `fromExpoWebClient` to make sure other message\n  // will not override content such as `notificationIcon`.\n  // https://stackoverflow.com/a/35729334/2603230\n  const notificationIcon = (Constants.expoConfig?.notification ?? {}).icon;\n  await registration.active.postMessage(\n    JSON.stringify({ fromExpoWebClient: { notificationIcon } })\n  );\n\n  return subscriptionObject;\n}\n\n// https://github.com/web-push-libs/web-push#using-vapid-key-for-applicationserverkey\nfunction _urlBase64ToUint8Array(base64String: string): Uint8Array {\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');\n\n  const rawData = window.atob(base64);\n  const outputArray = new Uint8Array(rawData.length);\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}\n"]},"metadata":{},"sourceType":"module"}